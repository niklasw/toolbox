#!/usr/bin/python
# Ripped parts from
# http://nbviewer.ipython.org/github/barbagroup/AeroPython/blob/master/lessons/02_Lesson02_sourceSinkFreestream.ipynb


from math import *
import numpy as np
import matplotlib.pyplot as plt


def get_velocity(strength, xs, ys, X, Y):
    """Returns the velocity field generated by a source/sink.

    Arguments
    ---------
    strength -- strength of the source/sink.
    xs, ys -- coordinates of the source/sink.
    X, Y -- mesh grid.
    """
    u = strength/(2*pi)*(X-xs)/((X-xs)**2+(Y-ys)**2)
    v = strength/(2*pi)*(Y-ys)/((X-xs)**2+(Y-ys)**2)

    return u, v

def get_velocity_3d(strength, xs, ys, X, Y):
    """Returns the velocity field generated by a source/sink.

    Arguments
    ---------
    strength -- strength of the source/sink.
    xs, ys -- coordinates of the source/sink.
    X, Y -- mesh grid.
    """
    # Wolfram alpha expression: d/dx S*(1/sqrt((x+a)^2+y^2)-1/sqrt((x-a)^2+y^2))
    # Wolfram alpha expression: d/dy S*(1/sqrt((x+a)^2+y^2)-1/sqrt((x-a)^2+y^2))
    u = strength/(4*pi)*( (X-xs)/((X-xs)**2+Y**2)**3./2-(X+xs)/((X+xs)**2+Y**2)**3./2)
    v = strength/(4*pi)*( Y/((X-xs)**2+Y**2)**3./2-Y/((X+xs)**2+Y**2)**3./2)

    return u, v

def get_stream_function(strength, xs, ys, X, Y):
    """Returns the strem-function generated by a source/sink.

    Arguments
    ---------
    strength -- strength of the source/sink.
    xs, ys -- coordinates of the source/sink.
    X, Y -- mesh grid.
    """
    psi = strength/(2*pi)*np.arctan2((Y-ys), (X-xs))

    return psi

def get_stream_function_3d(strength, xs, ys, X, Y):
    """Returns the strem-function generated by a source/sink.

    Arguments
    ---------
    strength -- strength of the source/sink.
    xs, ys -- coordinates of the source/sink.
    X, Y -- mesh grid.
    At Z == 0
    """
    psi = -strength/(4*pi) * (1.0/np.sqrt( (X+xs)**2+Y**2 )-1.0/np.sqrt( (X-xs)**2+Y**2) )

    return psi

def get_waves(strength, depth, U, distance, g=9.81):
    """Returns steady-state waves resulting from rankine body"""
    # Adhere to the report terminology:
    M = float(strength)    # 4pi, since paper sez "source strength of M/4pi"
    f = float(depth)

    h = lambda R: 4*M/U * np.sqrt(2*np.pi*g/(R*U**2)) * np.exp(-g*f/U**2) * cos(g*R/U**2+np.pi/4)
    return [ h(r) for r in distance ]

def getWaveLength(U,g=9.81):
    """Wave length according to Shaffer/Yim"""
    return 2*pi*U**2/g

def Fr_d(U,depth,g=9.81):
    """Submersion length based Froude number"""
    return U/sqrt(depth*g)


def rankine_waves(strength, depth, U, source_x, distance, g=9.81):
    """Center line wave shape from a sink and a source, forming a Rankine body"""
    M = float(strength)         # 4pi, since paper sez "source strength of M/4pi"
    f = float(depth)
    c = float(source_x)

    Fr = Fr_d(U,f,g)            # Froud number of depth
    print Fr
    B = 8*M/(f**2*U*Fr) * exp(-1/Fr**2) * sin(c/(f*Fr**2))
    h2f = lambda R: B*sqrt(2*pi*f/R) * sin(R/(f*Fr**2) - 3*pi/4)

    return [f*h2f(R) for R in distance ]

def getSourceFromLength(l,U,c):
    """Verification only"""

    M = (l**2-c**2)**2/(l*c)*pi*U
    print "Source strength verification M = {0}".format(M)

    return M


u_inf = 1.5                      # freestream speed
strength_source = 0.5            # strength of the source
x_source, y_source = -1.5, 0.0   # location of the source

N = 200                               # Number of points in each direction
x_start, x_end = -2*x_source, 2*x_source            # x-direction boundaries
y_start, y_end = -1*x_source, 1*x_source            # y-direction boundaries
x = np.linspace(x_start, x_end, N)    # 1D-array for x
y = np.linspace(y_start, y_end, N)    # 1D-array for y
X, Y = np.meshgrid(x, y)              # generates a mesh grid

# computes the freestream velocity field
u_freestream = u_inf * np.ones((N, N), dtype=float)
v_freestream = np.zeros((N, N), dtype=float)

# computes the stream-function
psi_freestream = u_inf * Y


strength_sink = -strength_source        # strength of the sink
x_sink, y_sink = 1.5, 0.0   # location of the sink

# computes the stream-function
psi_source = get_stream_function_3d(strength_source, x_source, y_source, X, Y)
psi_sink = get_stream_function_3d(strength_sink, x_sink, y_sink, X, Y)

u_source, v_source = get_velocity_3d(strength_source, x_source, y_source, X, Y)
u_sink, v_sink = get_velocity_3d(strength_sink, x_sink, y_sink, X, Y)


# superposition of a source and a sink on the freestream
u = u_freestream + u_source + u_sink
v = v_freestream + v_source + v_sink
psi = psi_freestream + psi_source + psi_sink

# plots the streamlines
#%matplotlib inline
size = 10
figureSize = (size, (y_end-y_start)/(x_end-x_start)*size)

plt.figure(figsize=figureSize)
plt.grid(True)
plt.xlabel('x', fontsize=16)
plt.ylabel('y', fontsize=16)
plt.xlim(x_start, x_end)
plt.ylim(y_start, y_end)
plt.streamplot(X, Y, u, v, density=2, linewidth=1, arrowsize=1, arrowstyle='->')
plt.scatter([x_source, x_sink], [y_source, y_sink], color='#CD2305', s=80, marker='o')

# calculates the stagnation point
x_stagnation = x_source - strength_source/(2*pi*u_inf)
y_stagnation = y_source

# adding the stagnation point to the figure
plt.scatter(x_stagnation, y_stagnation, color='g', s=80, marker='o')

# adds the dividing line to the figure
plt.contour(X, Y, psi,
            levels=[0.],
            colors='#CD2305', linewidths=2, linestyles='solid');


# computes the pressure coefficient field
cp = 1.0 - (u**2+v**2)/u_inf**2

# plots the pressure coefficient field
plt.figure(figsize=figureSize)
plt.xlabel('x', fontsize=16)
plt.ylabel('y', fontsize=16)
plt.xlim(x_start, x_end)
plt.ylim(y_start, y_end)
contf = plt.contourf(X, Y, cp, levels=np.linspace(-2.0, 1.0, 100), extend='both')
cbar = plt.colorbar(contf)
cbar.set_label('$C_p$', fontsize=16)
cbar.set_ticks([-2.0, -1.0, 0.0, 1.0])
plt.scatter([x_source, x_sink], [y_source, y_sink], color='#CD2305', s=80, marker='o')
plt.contour(X, Y, psi, levels=[0.], colors='#CD2305', linewidths=2, linestyles='solid');


print "Body length = {0}".format(-x_stagnation*2)

# stationary wave generation according to Yim/Shaffer

g = 9.81
operatingDepth = 2
waveLength = getWaveLength(u_inf,g)
maxLength = 15*waveLength
print "Wave length = {0}\nDepth Froude number = {1}".format(waveLength, Fr_d(u_inf,operatingDepth))
distance = np.arange(0.1,maxLength,0.01)

wh = rankine_waves(strength_source, operatingDepth, u_inf, x_sink, distance)


plt.figure()
plt.xlabel('Distance')
plt.ylabel('Centerline surface elevation')
plt.plot(distance,wh)
plt.grid('on')
plt.xlim(0,maxLength)
plt.ylim(-1.1*np.max(wh),1.1*np.max(wh))

getSourceFromLength(-x_stagnation*2,u_inf,x_sink)

plt.show()

